(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{635:function(s,e,a){"use strict";a.r(e);var n=a(3),t=Object(n.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"typescript高级类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript高级类型"}},[s._v("#")]),s._v(" Typescript高级类型")]),s._v(" "),a("h2",{attrs:{id:"一、是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、是什么"}},[s._v("#")]),s._v(" 一、是什么")]),s._v(" "),a("p",[s._v("除了"),a("code",[s._v("string")]),s._v("、"),a("code",[s._v("number")]),s._v("、"),a("code",[s._v("boolean")]),s._v(" 这种基础类型外，在 "),a("code",[s._v("typescript")]),s._v(" 类型声明中还存在一些高级的类型应用")]),s._v(" "),a("p",[s._v("这些高级类型，是"),a("code",[s._v("typescript")]),s._v("为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景")]),s._v(" "),a("h2",{attrs:{id:"二、有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、有哪些"}},[s._v("#")]),s._v(" 二、有哪些")]),s._v(" "),a("p",[s._v("常见的高级类型有如下：")]),s._v(" "),a("ul",[a("li",[s._v("交叉类型")]),s._v(" "),a("li",[s._v("联合类型")]),s._v(" "),a("li",[s._v("类型别名")]),s._v(" "),a("li",[s._v("类型索引")]),s._v(" "),a("li",[s._v("类型约束")]),s._v(" "),a("li",[s._v("映射类型")]),s._v(" "),a("li",[s._v("条件类型")])]),s._v(" "),a("p",[s._v("交叉类型")]),s._v(" "),a("p",[s._v("通过 "),a("code",[s._v("&")]),s._v(" 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作")]),s._v(" "),a("p",[s._v("语法如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("T & U\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function extend<T , U>(first: T, second: U) : T & U {\n    let result: <T & U> = {}\n    for (let key in first) {\n        result[key] = first[key]\n    }\n    for (let key in second) {\n        if(!result.hasOwnProperty(key)) {\n            result[key] = second[key]\n        }\n    }\n    return result\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h3",{attrs:{id:"联合类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#联合类型"}},[s._v("#")]),s._v(" 联合类型")]),s._v(" "),a("p",[s._v("联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系")]),s._v(" "),a("p",[s._v("语法如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("T | U\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("例如 "),a("code",[s._v("number")]),s._v(" | "),a("code",[s._v("string")]),s._v(" | "),a("code",[s._v("boolean")]),s._v(" 的类型只能是这三个的一种，不能共存")]),s._v(" "),a("p",[s._v("如下所示：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function formatCommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h3",{attrs:{id:"类型别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型别名"}},[s._v("#")]),s._v(" 类型别名")]),s._v(" "),a("p",[s._v("类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型")]),s._v(" "),a("p",[s._v("可以使用 "),a("code",[s._v("type SomeName = someValidTypeAnnotation")]),s._v("的语法来创建类型别名：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type some = boolean | string\n\nconst b: some = true // ok\nconst c: some = 'hello' // ok\nconst d: some = 123 // 不能将类型“123”分配给类型“some”\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("此外类型别名可以是泛型:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type Container<T> = { value: T };\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("也可以使用类型别名来在属性里引用自己：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type Tree<T> = {\n    value: T;\n    left: Tree<T>;\n    right: Tree<T>;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数")]),s._v(" "),a("p",[s._v("两者最大的区别在于，"),a("code",[s._v("interface")]),s._v("只能用于定义对象类型，而 "),a("code",[s._v("type")]),s._v(" 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛")]),s._v(" "),a("h3",{attrs:{id:"类型索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型索引"}},[s._v("#")]),s._v(" 类型索引")]),s._v(" "),a("p",[a("code",[s._v("keyof")]),s._v(" 类似于 "),a("code",[s._v("Object.keys")]),s._v(" ，用于获取一个接口中 Key 的联合类型。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('interface Button {\n    type: string\n    text: string\n}\n\ntype ButtonKeys = keyof Button\n// 等效于\ntype ButtonKeys = "type" | "text"\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h3",{attrs:{id:"类型约束"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型约束"}},[s._v("#")]),s._v(" 类型约束")]),s._v(" "),a("p",[s._v("通过关键字 "),a("code",[s._v("extend")]),s._v(" 进行约束，不同于在 "),a("code",[s._v("class")]),s._v(" 后使用 "),a("code",[s._v("extends")]),s._v(" 的继承作用，泛型内使用的主要作用是对泛型加以约束")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type BaseType = string | number | boolean\n\n// 这里表示 copy 的参数\n// 只能是字符串、数字、布尔这几种基础类型\nfunction copy<T extends BaseType>(arg: T): T {\n  return arg\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 "),a("code",[s._v("extends")]),s._v(" 和 "),a("code",[s._v("keyof")]),s._v(" 进行约束。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function getValue<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key]\n}\n\nconst obj = { a: 1 }\nconst a = getValue(obj, 'a')\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h3",{attrs:{id:"映射类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#映射类型"}},[s._v("#")]),s._v(" 映射类型")]),s._v(" "),a("p",[s._v("通过 "),a("code",[s._v("in")]),s._v(" 关键字做类型的映射，遍历已有接口的 "),a("code",[s._v("key")]),s._v(" 或者是遍历联合类型，如下例子：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\ninterface Obj {\n  a: string\n  b: string\n}\n\ntype ReadOnlyObj = Readonly<Obj>\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("上述的结构，可以分成这些步骤：")]),s._v(" "),a("ul",[a("li",[s._v("keyof T：通过类型索引 keyof 的得到联合类型 'a' | 'b'")]),s._v(" "),a("li",[s._v("P in keyof T 等同于 p in 'a' | 'b'，相当于执行了一次 forEach 的逻辑，遍历 'a' | 'b'")])]),s._v(" "),a("p",[s._v("所以最终"),a("code",[s._v("ReadOnlyObj")]),s._v("的接口为下述：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("interface ReadOnlyObj {\n    readonly a: string;\n    readonly b: string;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h3",{attrs:{id:"条件类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件类型"}},[s._v("#")]),s._v(" 条件类型")]),s._v(" "),a("p",[s._v("条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("T extends U ? X : Y\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y")])])}),[],!1,null,null,null);e.default=t.exports}}]);